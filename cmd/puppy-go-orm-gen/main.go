package main

import (
	"database/sql"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"

	_ "github.com/go-sql-driver/mysql"
)

type Column struct {
	Name       string
	GoName     string
	DataType   string
	GoType     string
	IsNullable bool
	IsPK       bool
	Tag        string
}

type Table struct {
	Name        string
	GoName      string
	PackageName string
	Columns     []Column
	NeedsTime   bool
}

var structTpl = template.Must(template.New("struct").Parse(`// Code generated by puppy-go-orm-gen; DO NOT EDIT.
package {{.PackageName}}

{{- if .NeedsTime }}
import "time"
{{- end }}

type {{.GoName}} struct {
{{- range .Columns }}
    {{.GoName}} {{.GoType}} {{.Tag}}
{{- end }}
}
`))

func main() {
	dsn := flag.String("dsn", "", "MySQL DSN (e.g. user:pass@tcp(127.0.0.1:3306)/dbname?parseTime=true)")
	schema := flag.String("schema", "", "DB schema name")
	outDir := flag.String("out", "./models", "Output directory for generated models")
	pkg := flag.String("pkg", "models", "Go package name for generated files")
	tablesFilter := flag.String("tables", "", "Comma-separated list of tables (optional)")
	flag.Parse()

	if *dsn == "" || *schema == "" {
		log.Fatal("dsn and schema are required")
	}

	if err := os.MkdirAll(*outDir, 0o755); err != nil {
		log.Fatalf("cannot create out dir: %v", err)
	}

	db, err := sql.Open("mysql", *dsn)
	if err != nil {
		log.Fatalf("open db: %v", err)
	}
	defer db.Close()

	filterSet := map[string]bool{}
	if *tablesFilter != "" {
		for _, t := range strings.Split(*tablesFilter, ",") {
			filterSet[strings.TrimSpace(t)] = true
		}
	}

	tables, err := loadTables(db, *schema, filterSet, *pkg)
	if err != nil {
		log.Fatalf("loadTables: %v", err)
	}

	for _, t := range tables {
		if err := writeTable(*outDir, t); err != nil {
			log.Fatalf("writeTable(%s): %v", t.Name, err)
		}
	}

	log.Printf("Generated %d tables into %s", len(tables), *outDir)
}

func loadTables(db *sql.DB, schema string, filter map[string]bool, pkg string) ([]Table, error) {
	const q = `
SELECT
    TABLE_NAME,
    COLUMN_NAME,
    DATA_TYPE,
    IS_NULLABLE,
    COLUMN_KEY
FROM information_schema.columns
WHERE table_schema = ?
ORDER BY TABLE_NAME, ORDINAL_POSITION;
`
	rows, err := db.Query(q, schema)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	tableMap := map[string][]Column{}

	for rows.Next() {
		var tableName, colName, dataType, isNullable, colKey string
		if err := rows.Scan(&tableName, &colName, &dataType, &isNullable, &colKey); err != nil {
			return nil, err
		}

		if len(filter) > 0 && !filter[tableName] {
			continue
		}

		goName := snakeToCamel(colName)
		goType := sqlTypeToGoType(dataType, isNullable == "YES")
		isPK := (colKey == "PRI")

		tag := fmt.Sprintf("`gorm:\"column:%s", colName)
		if isPK {
			tag += ";primaryKey"
		}
		tag += fmt.Sprintf("\" json:\"%s\"`", colName)

		col := Column{
			Name:       colName,
			GoName:     goName,
			DataType:   dataType,
			GoType:     goType,
			IsNullable: isNullable == "YES",
			IsPK:       isPK,
			Tag:        tag,
		}

		tableMap[tableName] = append(tableMap[tableName], col)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	var tables []Table
	for name, cols := range tableMap {
		needsTime := false
		for _, c := range cols {
			if strings.Contains(c.GoType, "time.Time") {
				needsTime = true
				break
			}
		}

		tables = append(tables, Table{
			Name:        name,
			GoName:      snakeToCamelSingular(name),
			PackageName: pkg,
			Columns:     cols,
			NeedsTime:   needsTime,
		})
	}

	return tables, nil
}

func writeTable(outDir string, t Table) error {
	fname := filepath.Join(outDir, fmt.Sprintf("%s.gen.go", t.Name))
	f, err := os.Create(fname)
	if err != nil {
		return err
	}
	defer f.Close()

	return structTpl.Execute(f, t)
}

// type mapping (can improve later)
func sqlTypeToGoType(sqlType string, nullable bool) string {
	st := strings.ToLower(sqlType)
	var base string

	switch {
	case strings.Contains(st, "int"):
		base = "int64"
	case strings.Contains(st, "decimal"), strings.Contains(st, "numeric"),
		strings.Contains(st, "float"), strings.Contains(st, "double"):
		base = "float64"
	case strings.Contains(st, "bool"):
		base = "bool"
	case strings.Contains(st, "date"), strings.Contains(st, "time"):
		base = "time.Time"
	default:
		base = "string"
	}

	if nullable && base != "string" {
		return "*" + base
	}
	return base
}

func snakeToCamel(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if p == "" {
			continue
		}
		parts[i] = strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
	}
	return strings.Join(parts, "")
}

func snakeToCamelSingular(s string) string {
	if strings.HasSuffix(s, "s") && len(s) > 1 {
		s = s[:len(s)-1]
	}
	cc := snakeToCamel(s)
	r := []rune(cc)
	if len(r) > 0 {
		r[0] = unicode.ToUpper(r[0])
	}
	return string(r)
}
